Напишем свой аналог листа таблицы Excel. Нужно написать структуру данных Field,
в которой доступ к значениям будет осуществляться по ключам. Ключом будет пара
"буква" - "число", по аналогии с адресом ячейки в Excel. Возможные форматы обращения
к одной и той же "ячейке" данных:

field = Field()

field[1, 'a'] = 25
field['a', 1] = 25
field['a', '1'] = 25
field['1', 'a'] = 25
field['1a'] = 25
field['a1'] = 25
field[1, 'A'] = 25
field['A', 1] = 25
field['A', '1'] = 25
field['1', 'A'] = 25
field['1A'] = 25
field['A1'] = 25

В этом списке каждая из этих строк записывает число 25 в ячейку с одним и тем же ключом.
Соответственно, по любому из перечисленных ключей должно быть можно получить это число из
объекта field. Также должны быть реализованы удаление элемента из структуры (через оператор del)
и возможность использования оператора in, например:

(1, 'a') in field: True
"A1" in field: True
('D', '4') in field: False

Таким образом, выходит, что ключом структуры может быть либо кортеж, либо строка.
При попытке получить или записать значение по ключу другого типа должно быть
вызвано исключение TypeError. При некорректном значении строки или элементов
кортежа нужно вызывать исключение ValueError. Корректными значениями будет считать
одиночные буквы и неотрицательное целое число любой длины, т.е. правильные варианты ключей:

А1
А222543
Z89

Неправильные варианты ключей:

AA5
Q2.5
-6F
A
27
GG

Кроме вышеперчисленного, по объекту должно быть возможно итерироваться. При проходе циклом
по объекту должны возвращаться значения, хранящиеся в нём. Порядок возврата значений не важен.

Если запрашивается правильный формат ячейки, но в нашем контейнере такого ключа нет, то
нужно вернуть None. Например:

field = Field()
print(field["C5"] is None)
> True

*Продолжение задания*

Доработать класс Field так, чтобы вдобавок к реализованному функционалу
появились следующие возможности:

field = Field()

Запись значения в ячейку:

field.a1 = 25: эквивалентно field['a1'] = 25
field.A1 = 25: то же самое

Получение значения:

  field['b', 2] = 100
  field.b2
  field.B2

Удаление значения:

del field.a1, del field.A1 - эквивалентно del field['a', 1]

Таким образом, внутри класса Field методы работы с атрибутами должны работать
с тем же объектом, в котором хранятся значения, обрабатываемые в методах __setitem__,
__getitem__, __delitem__.

Кроме того, обычное присвоение и получение атрибутов (тех, которые не являются
адресом ячейки данных нашего класса) должно производиться по стандартному алгоритму
питоновских объектов, т.е. они должны храниться в словаре __dict__ объекта.

field = Field()
field.abcde = 125
print(field.abcde, field.__dict__['abcde'] == 125)
125 True

Для таких атрибутов также должны быть реализованы получение, присваивание и удаление значения.